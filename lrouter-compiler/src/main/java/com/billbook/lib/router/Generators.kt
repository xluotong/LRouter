package com.billbook.lib.router

import com.billbook.lib.router.internal.DefaultModule
import com.billbook.lib.router.internal.ModuleContainer
import com.squareup.javapoet.*
import java.lang.StringBuilder
import java.util.*
import javax.annotation.Generated
import javax.annotation.processing.Filer
import javax.lang.model.element.Modifier
import javax.tools.StandardLocation
import kotlin.collections.ArrayList

private fun String.simple() = this.split(".").let { it[it.lastIndex] }

/**
 * @author xluotong@gmail.com
 */
private fun ModuleMeta.writeServiceContainerClassTo(filer: Filer) {
    val moduleMeta = this
    JavaFile.builder(
        PACKAGE_GENERATE,
        TypeSpec.classBuilder(moduleMeta.container.simple())
            .addJavadoc("Generated by lrouter, please do not edit it!")
            .addAnnotation(
                AnnotationSpec.builder(Generated::class.java)
                    .addMember("value", "\$S", "LRouterGeneartor")
                    .addMember("comments", "\$S", "Generated by lrouter, please do not edit it!")
                    .build()
            )
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .superclass(ClassName.get(ModuleContainer::class.java))
            .addMethod(
                MethodSpec.constructorBuilder()
                    .addModifiers(Modifier.PUBLIC)
                    .addStatement(
                        "super(new \$T(\$S,\$L))",
                        DefaultModule::class.java,
                        moduleMeta.name,
                        "null"
                    )
                    .build()
            )
            .addMethod(
                MethodSpec.methodBuilder("getServices")
                    .addModifiers(Modifier.PUBLIC)
                    .addAnnotation(Override::class.java)
                    .addCode(
                        if (moduleMeta.serviceMetas.isEmpty()) {
                            CodeBlock.builder().addStatement(
                                "return \$T.emptyList()",
                                Collections::class.java
                            ).build()
                        } else {
                            CodeBlock.builder().addStatement(
                                "\$T<\$T<?>> services = new \$T<>()",
                                List::class.java,
                                ServiceInfo::class.java,
                                ArrayList::class.java
                            ).apply {
                                moduleMeta.serviceMetas.forEach { serviceMeta ->
                                    this.addStatement(
                                        "services.add(new \$T(\$T.class,\$T.class,\$S,\$S,\$T.\$L))",
                                        ServiceInfo::class.java,
                                        serviceMeta.definition.toClassName(),
                                        serviceMeta.service.toClassName(),
                                        serviceMeta.name,
                                        serviceMeta.desc,
                                        ClassName.get(CacheIn::class.java),
                                        if (serviceMeta.singleton) CacheIn.SINGLETON else CacheIn.UNDEFINED
                                    )
                                }

                            }.addStatement("return services").build()
                        }
                    )
                    .returns(
                        ParameterizedTypeName.get(
                            List::class.java.toClassName(),
                            ParameterizedTypeName.get(
                                ServiceInfo::class.java.toClassName(),
                                WildcardTypeName.subtypeOf(Object::class.java)
                            )
                        )
                    )
                    .build()
            )
            .addMethod(
                MethodSpec.methodBuilder("getRoutes")
                    .addModifiers(Modifier.PUBLIC)
                    .addAnnotation(Override::class.java)
                    .addCode(
                        if(moduleMeta.routeMetas.isEmpty()) {
                            CodeBlock.builder().addStatement(
                                "return \$T.emptyList()",
                                Collections::class.java
                            ).build()
                        } else {
                            CodeBlock.builder().addStatement(
                                "\$T<\$T> routes = new \$T<>()",
                                List::class.java,
                                RouteInfo::class.java,
                                ArrayList::class.java
                            ).apply {
                                moduleMeta.routeMetas.forEach { routeMeta ->
                                    if(routeMeta.interceptors.isEmpty()){
                                        this.addStatement(
                                            "routes.add(new \$T(\$S,\$S,\$S,\$S,\$S,\$S,\$T.class,\$T.\$L,\$L))",
                                            RouteInfo::class.java,
                                            routeMeta.path,
                                            routeMeta.scheme,
                                            routeMeta.host,
                                            routeMeta.group,
                                            routeMeta.groupDesc,
                                            routeMeta.desc,
                                            routeMeta.definition.toClassName(),
                                            RouteType::class.java,
                                            routeMeta.type,
                                            "null"
                                        )
                                    } else {
                                        val formatBuilder = StringBuilder("routes.add(new \$T(\$S,\$S,\$S,\$S,\$S,\$S,\$T.class,\$T.\$L,\$T.asList(")
                                        routeMeta.interceptors.forEachIndexed { index,_ ->
                                            formatBuilder.append("\$T.class")
                                            if(index != routeMeta.interceptors.lastIndex){
                                                formatBuilder.append(", ")
                                            }
                                        }
                                        formatBuilder.append(")))")
                                        this.addStatement(
                                            formatBuilder.toString(),
                                            RouteInfo::class.java,
                                            routeMeta.path,
                                            routeMeta.scheme,
                                            routeMeta.host,
                                            routeMeta.group,
                                            routeMeta.groupDesc,
                                            routeMeta.desc,
                                            routeMeta.definition.toClassName(),
                                            RouteType::class.java,
                                            routeMeta.type,
                                            Arrays::class.java,
                                            *routeMeta.interceptors.map { it.toClassName() }.toTypedArray()
                                        )
                                    }
                                }

                            }.addStatement("return routes").build()
                        }
                    )
                    .returns(
                        ParameterizedTypeName.get(
                            List::class.java.toClassName(),
                            RouteInfo::class.java.toClassName()
                        )
                    )
                    .build()
            )
            .build()
    ).build().writeTo(filer)
}

internal fun ModuleMeta.writeTo(filer: Filer) {
    this.writeServiceContainerClassTo(filer)
    this.writeMetaInfoTo(filer)
}

private fun ModuleMeta.writeMetaInfoTo(filer: Filer) {
    filer.createResource(StandardLocation.CLASS_OUTPUT, "", META_DATA_PATH).openWriter()
        .use { it.write(globalGson.toJson(this)) }
}