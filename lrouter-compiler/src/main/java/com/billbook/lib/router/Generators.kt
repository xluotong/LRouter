package com.billbook.lib.router

import com.billbook.lib.router.internal.ModuleContainer
import com.billbook.lib.router.internal.RouteInfo
import com.billbook.lib.router.internal.ServiceRegistry
import com.squareup.javapoet.*
import java.lang.reflect.WildcardType
import java.util.*
import javax.annotation.Generated
import javax.annotation.processing.Filer
import javax.lang.model.element.Modifier
import javax.tools.StandardLocation
import kotlin.collections.ArrayList

private fun String.simple() = this.split(".").let { if (it.size > 1) it[1] else it[0] }

/**
 * @author xluotong@gmail.com
 */
private fun ModuleMeta.writeServiceContainerClassTo(filer: Filer) {
    val moduleMeta = this
    JavaFile.builder(
        PACKAGE_GENERATE,
        TypeSpec.classBuilder(moduleMeta.container.simple())
            .addJavadoc("Generated by lrouter, please do not edit it!")
            .addAnnotation(
                AnnotationSpec.builder(Generated::class.java)
                    .addMember("value", "\$S", "LRouterGeneartor")
                    .addMember("comments", "\$S", "Generated by lrouter, please do not edit it!")
                    .build()
            )
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .superclass(ClassName.get(ModuleContainer::class.java))
            .addMethod(
                MethodSpec.methodBuilder("getServices")
                    .addModifiers(Modifier.PUBLIC)
                    .addAnnotation(Override::class.java)
                    .addCode(
                        if (moduleMeta.serviceMetas.isEmpty()) {
                            CodeBlock.builder().addStatement(
                                "return \$T.emptyList<ServiceInfo<*>>()",
                                Collections::class.java
                            )
                                .build()
                        } else {
                            CodeBlock.builder().apply {
                                this.addStatement(
                                    "\$T<\$T<?>> services = new \$T<>()",
                                    List::class.java,
                                    ServiceInfo::class.java,
                                    ArrayList::class.java
                                )
                                moduleMeta.serviceMetas.forEach { serviceMeta ->
                                    this.addStatement(
                                        "services.add(new \$T(\$T.class,\$T.class,\$S,\$S,\$T.\$L))",
                                        ServiceInfo::class.java,
                                        serviceMeta.definition.toClassName(),
                                        serviceMeta.service.toClassName(),
                                        serviceMeta.name,
                                        serviceMeta.desc,
                                        ClassName.get(CacheIn::class.java),
                                        if (serviceMeta.singleton) CacheIn.SINGLETON else CacheIn.UNDEFINED
                                    )
                                }
                                addStatement("return services")
                            }.build()
                        }
                    )
                    .returns(
                        ParameterizedTypeName.get(
                            List::class.java.toClassName(),
                            ParameterizedTypeName.get(
                                ServiceInfo::class.java.toClassName(),
                                WildcardTypeName.subtypeOf(Object::class.java)
                            )
                        )
                    )
                    .build()
            )
            .addMethod(
                MethodSpec.methodBuilder("getRoutes")
                    .addModifiers(Modifier.PUBLIC)
                    .addAnnotation(Override::class.java)
                    .addCode(
                        CodeBlock.builder().addStatement(
                            "return \$T.emptyList<\$T>>()",
                            Collections::class.java, RouteInfo::class.java
                        ).build()
                    )
                    .returns(
                        ParameterizedTypeName.get(
                            List::class.java.toClassName(),
                            RouteInfo::class.java.toClassName()
                        )
                    )
                    .build()
            )
            .build()
    ).build().writeTo(filer)
}

internal fun ModuleMeta.writeTo(filer: Filer) {
    this.writeServiceContainerClassTo(filer)
    this.writeMetaInfoTo(filer)
}

private fun ModuleMeta.writeMetaInfoTo(filer: Filer) {
    filer.createResource(StandardLocation.CLASS_OUTPUT, "", META_DATA_PATH).openWriter()
        .use { it.write(globalGson.toJson(this)) }
}