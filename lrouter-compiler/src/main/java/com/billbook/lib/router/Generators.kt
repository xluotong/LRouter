package com.billbook.lib.router

import com.billbook.lib.router.internal.ModuleContainer
import com.squareup.javapoet.*
import java.util.*
import javax.annotation.Generated
import javax.annotation.processing.Filer
import javax.lang.model.element.Modifier
import javax.lang.model.util.Elements
import javax.lang.model.util.Types
import javax.tools.StandardLocation
import kotlin.collections.ArrayList

private fun String.simple() = this.split(".").let { it[it.lastIndex] }

internal const val INJECTOR_CLASS_FORMAT = "%s\$\$RouterInjector"

/**
 * @author xluotong@gmail.com
 */
private fun ModuleMeta.writeServiceContainerClassTo(filer: Filer) {
    val moduleMeta = this
    JavaFile.builder(
        PACKAGE_GENERATE,
        TypeSpec.classBuilder(moduleMeta.container.simple())
            .addJavadoc("Generated by lrouter, please do not edit it!")
            .addAnnotation(
                AnnotationSpec.builder(Generated::class.java)
                    .addMember("value", "\$S", "LRouterGeneartor")
                    .addMember("comments", "\$S", "Generated by lrouter, please do not edit it!")
                    .build()
            )
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .superclass(ClassName.get(ModuleContainer::class.java))
            .addMethod(
                MethodSpec.constructorBuilder()
                    .addModifiers(Modifier.PUBLIC)
                    .addStatement(
                        "super(new \$T(\$S,\$L))",
                        DefaultModule::class.java,
                        moduleMeta.name,
                        "null"
                    )
                    .build()
            )
            .addMethod(
                MethodSpec.methodBuilder("getServices")
                    .addModifiers(Modifier.PUBLIC)
                    .addAnnotation(Override::class.java)
                    .addCode(
                        if (moduleMeta.serviceMetas.isEmpty()) {
                            CodeBlock.builder().addStatement(
                                "return \$T.emptyList()",
                                Collections::class.java
                            ).build()
                        } else {
                            CodeBlock.builder().addStatement(
                                "\$T<\$T<?>> services = new \$T<>()",
                                List::class.java,
                                ServiceInfo::class.java,
                                ArrayList::class.java
                            ).apply {
                                moduleMeta.serviceMetas.forEach { serviceMeta ->
                                    this.addStatement(
                                        "services.add(new \$T(\$T.class,\$T.class,\$S,\$S,\$T.\$L))",
                                        ServiceInfo::class.java,
                                        serviceMeta.definition.toClassName(),
                                        serviceMeta.service.toClassName(),
                                        serviceMeta.name,
                                        serviceMeta.desc,
                                        ClassName.get(CacheIn::class.java),
                                        if (serviceMeta.singleton) CacheIn.SINGLETON else CacheIn.UNDEFINED
                                    )
                                }

                            }.addStatement("return services").build()
                        }
                    )
                    .returns(
                        ParameterizedTypeName.get(
                            List::class.java.toClassName(),
                            ParameterizedTypeName.get(
                                ServiceInfo::class.java.toClassName(),
                                WildcardTypeName.subtypeOf(Object::class.java)
                            )
                        )
                    )
                    .build()
            )
            .addMethod(
                MethodSpec.methodBuilder("getRoutes")
                    .addModifiers(Modifier.PUBLIC)
                    .addAnnotation(Override::class.java)
                    .addCode(
                        if (moduleMeta.routeMetas.isEmpty()) {
                            CodeBlock.builder().addStatement(
                                "return \$T.emptyList()",
                                Collections::class.java
                            ).build()
                        } else {
                            CodeBlock.builder().addStatement(
                                "\$T<\$T> routes = new \$T<>()",
                                List::class.java,
                                RouteInfo::class.java,
                                ArrayList::class.java
                            ).apply {
                                moduleMeta.routeMetas.forEach { routeMeta ->
                                    if (routeMeta.interceptors.isEmpty()) {
                                        this.addStatement(
                                            "routes.add(new \$T(\$S,\$S,\$S,\$S,\$S,\$S,\$T.class,\$T.\$L,\$T.class,\$L))",
                                            RouteInfo::class.java,
                                            routeMeta.path,
                                            routeMeta.scheme,
                                            routeMeta.host,
                                            routeMeta.group,
                                            routeMeta.groupDesc,
                                            routeMeta.desc,
                                            routeMeta.definition.toClassName(),
                                            RouteType::class.java,
                                            routeMeta.type,
                                            if (routeMeta.launcher.isNotEmpty()) routeMeta.launcher.toClassName() else Launcher::class.java,
                                            "null"
                                        )
                                    } else {
                                        val formatBuilder =
                                            StringBuilder("routes.add(new \$T(\$S,\$S,\$S,\$S,\$S,\$S,\$T.class,\$T.\$L,\$T.class, \$T.asList(")
                                        routeMeta.interceptors.forEachIndexed { index, _ ->
                                            formatBuilder.append("\$T.class")
                                            if (index != routeMeta.interceptors.lastIndex) {
                                                formatBuilder.append(", ")
                                            }
                                        }
                                        formatBuilder.append(")))")
                                        this.addStatement(
                                            formatBuilder.toString(),
                                            RouteInfo::class.java,
                                            routeMeta.path,
                                            routeMeta.scheme,
                                            routeMeta.host,
                                            routeMeta.group,
                                            routeMeta.groupDesc,
                                            routeMeta.desc,
                                            routeMeta.definition.toClassName(),
                                            RouteType::class.java,
                                            routeMeta.type,
                                            if (routeMeta.launcher.isNotEmpty()) routeMeta.launcher.toClassName() else Launcher::class.java,
                                            Arrays::class.java,
                                            *routeMeta.interceptors.map { it.toClassName() }
                                                .toTypedArray()
                                        )
                                    }
                                }

                            }.addStatement("return routes").build()
                        }
                    )
                    .returns(
                        ParameterizedTypeName.get(
                            List::class.java.toClassName(),
                            RouteInfo::class.java.toClassName()
                        )
                    )
                    .build()
            )
            .build()
    ).build().writeTo(filer)
}

internal fun ModuleMeta.writeTo(filer: Filer) {
    this.writeServiceContainerClassTo(filer)
    this.writeInjectorClassTo(filer)
    this.writeMetaInfoTo(filer)
}

private fun ModuleMeta.writeMetaInfoTo(filer: Filer) {
    filer.createResource(StandardLocation.CLASS_OUTPUT, "", META_DATA_PATH).openWriter()
        .use { it.write(globalGson.toJson(this)) }
}

private fun ModuleMeta.writeInjectorClassTo(filer: Filer) {
    if (this.injectMeta.isEmpty()) return
    this.injectMeta.forEach { injectMeta ->
        val targetClassName = injectMeta.target.targetClass.toClassName()
        JavaFile.builder(
            injectMeta.target.packageName,
            TypeSpec.classBuilder(
                String.format(
                    INJECTOR_CLASS_FORMAT,
                    injectMeta.target.targetClass.simple()
                )
            ).addJavadoc("Generated by LRouter, please do not edit it!")
                .addModifiers(Modifier.PUBLIC)
                .addSuperinterface(
                    ParameterizedTypeName.get(
                        ClassName.get(Injector::class.java),
                        targetClassName
                    )
                ).addMethod(
                    MethodSpec.methodBuilder("inject")
                        .addParameter(targetClassName, "target")
                        .addModifiers(Modifier.PUBLIC)
                        .addCode(CodeBlock.builder().apply {
                            injectMeta.autowiredList.forEach { field ->
                                val statement = when (injectMeta.target.type) {
                                    InjectMeta.TargetType.ACTIVITY -> {
                                        field.opIntentExtraStatement(
                                            "target.${field.name}"
                                        )
                                    }
                                    InjectMeta.TargetType.FRAGMENT -> {
                                        field.opArgumentsExtraStatement(
                                            "target.${field.name}"
                                        )
                                    }
                                    else -> error("Unsupported autowired target: $targetClassName!")
                                }
                                this.addStatement(
                                    "target.${field.name} = $statement", field.injectName
                                )
                            }
                            injectMeta.serviceList.forEach { field ->
                                this.addStatement(
                                    "target.${field.name} = \$T.getService(\$T.class)",
                                    LRouter::class.java,
                                    field.type.toClassName()
                                )
                            }
                        }.build())
                        .returns(TypeName.VOID)
                        .addAnnotation(Override::class.java)
                        .build()
                )
                .build()
        ).build().writeTo(filer)
    }
}

private fun InjectMeta.Field.opIntentExtraStatement(default: String): String {
    return when (this.type) {
        AndroidTypeKind.BOOLEAN -> "target.getIntent().getBooleanExtra(\$S,$default)"
        AndroidTypeKind.BYTE -> "target.getIntent().getByteExtra(\$S,$default)"
        AndroidTypeKind.SHORT -> "target.getIntent().getShortExtra(\$S,$default)"
        AndroidTypeKind.INT -> "target.getIntent().getIntExtra(\$S,$default)"
        AndroidTypeKind.LONG -> "target.getIntent().getLongExtra(\$S,$default)"
        AndroidTypeKind.CHAR -> "target.getIntent().getCharExtra(\$S,$default)"
        AndroidTypeKind.FLOAT -> "target.getIntent().getFloatExtra(\$S,$default)"
        AndroidTypeKind.DOUBLE -> "target.getIntent().getDoubleExtra(\$S,$default)"
        AndroidTypeKind.STRING -> "target.getIntent().getStringExtra(\$S)"
        AndroidTypeKind.SERIALIZABLE -> "target.getIntent().getSerializableExtra(\$S)"
        AndroidTypeKind.PARCELABLE -> "target.getIntent().getParcelableExtra(\$S)"
        else -> error("Unsupported autowired type!")
    }
}

private fun InjectMeta.Field.opArgumentsExtraStatement(default: String): String {
    return when (this.type) {
        AndroidTypeKind.BOOLEAN -> "target.getArguments().getBoolean(\$S,$default)"
        AndroidTypeKind.BYTE -> "target.getArguments().getByte(\$S,$default)"
        AndroidTypeKind.SHORT -> "target.getArguments().getShort(\$S,$default)"
        AndroidTypeKind.INT -> "target.getArguments().getInt(\$S,$default)"
        AndroidTypeKind.LONG -> "target.getArguments().getLong(\$S,$default)"
        AndroidTypeKind.CHAR -> "target.getArguments().getChar(\$S,$default)"
        AndroidTypeKind.FLOAT -> "target.getArguments().getFloat(\$S,$default)"
        AndroidTypeKind.DOUBLE -> "target.getArguments().getDouble(\$S,$default)"
        AndroidTypeKind.STRING -> "target.getArguments().getString(\$S)"
        AndroidTypeKind.SERIALIZABLE -> "target.getArguments().getSerializable(\$S)"
        AndroidTypeKind.PARCELABLE -> "target.getArguments().getParcelable(\$S)"
        else -> error("Unsupported autowired type!")
    }
}
